---
layout:     post
title:      谈谈设计模式
subtitle:   谈谈设计模式
date:       2020-12-17
author:     SkioFox
header-img: img/post-bg-iWatch.jpg
catalog: true
tags:
- 设计模式
---

### 设计模式的分类

* 创建型模式 ( `creational pattern` )
* 结构型模式 ( `Structural pattern` )
* 行为模式 ( `Behavioral pattern` )
* 并发模式 ( `Concurrency pattern` )

#### 1.创建型模式

在必须决定实例化某个类时，使用这些模式。

##### Singleton 模式特征

* 全局实例只有一个
* 允许延迟初始化(lazy instantiation)，而且在多线程环境中需要线程安全(thread-safe)
* 用户使用单例时，不用知道里面含有什么类，里面的类什么时候被实例化，只要知道要调用哪个接口(函数)即可。

##### Factory Method 模式特征

* 运行时决定创建的实例
* 创建多个实现同一接口的实

#### 2.结构型模式

这些模式涉及类如何相互继承或如何从其它类组合，他们的特征`往往是一种意图的不同`。

常用的结构型模式包括 Adapter、Proxy 和 Decorator 模式。因为这些模式在客户机类与其要使用的类之间引入了一个间接层，所以它们是类似的。但是，它们的意图有所不同:

* `Adapter` 使用这种间接修改类的接口以方便客户机类使用它。
* `Decorator` 使用这种间接向类添加行为， 而不会过度地影响客户机类。
* `Proxy` 使用这种间接透明地提供另一个类的替身。

##### Adapter 模式意图

原始类能够支持客户机类需要的行为，但没有客户机类希望的接口，而且改变原始类是不可能的，或是不切实际的。或许，是无法获得源代码，或者其它地方正在使用它，并且不适 合更改接口。

##### Decorator 模式意图

用对客户机类透明的方式来扩展原始类的功能。

##### Proxy 模式意图

当客户机希望使用某个类，而访问该类的方式很明显必须用间接的方式时 (例如，因为客户机需要受限访问或它是一个远程进程) ，应该使用 Proxy 模式。

##### Composite 模式意图

以一种一致的方式处理所有的组成对象。参与这一模式的所有对象，不管是简单还是复杂的，都是从定义公共行为的一个公共抽象组件类派生而来的。

用这种方法将各种关系强制转换成部分-整体的层次结构，从而使系统 (或客户机子系统) 需要管理的对象类型变得最小。例如，画图程序的客户机以它要求其它对象 (包括组合对象) 的相同方式要求线条画出自身。

#### 3.行为模式

规定了对象之间交互的方式。它们通过指定对象的职责和对象相互通信的方式，使得复杂的行为易于管理。

##### Observer 模式

`模型`／`视图`／`控制器` (Model/View/Controller) "体系结构实现应用程序时，通常会使用这一模式。该设计的"模型／视图"部分是为了去除数据的表示与数据本身的耦合性。
